<?php

/**
 * @file
 * Contains eba.module..
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\eba\Helpers\EbaConfig;

/**
 * Implements hook_help().
 */
function eba_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the eba module.
    case 'help.page.eba':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Attach a block to an entity bundle') . '</p>';
      return $output;

    default:
  }
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function eba_form_block_admin_configure_alter(&$form, FormStateInterface $form_state, $form_id) {
  list($module, $delta) = $form_state['build_info']['args'];
  $config = EbaConfig::get($module, $delta);

  // @TODO Organise this form in a friendlier way. Tabs within tabs? Fieldsets?
  $parent_element = [
    '#tree' => TRUE,
    '#type' => 'fieldset',
    '#title' => t('Entity bundles to display this block on'),
    '#description' => t('Make this block display on every entity of the selected types. Note that once a block is set to display, it will instantly appear on all view modes of any entity of that type/bundle unless hidden through the \'Manage display\' fields interface for that entity type/bundle. Use that same interface to re-order this block amongst the entity\'s fields.'),
  ];

  // Manually set #options so that they can appear grouped by entity type.
  // Groupings are implemented as a label in the #prefix of the first checkbox
  // option for each entity type.
  // TODO: change out deprecated entityManager
  $entity_info = \Drupal::entityManager()->getDefinitions();
  foreach ($entity_info as $entity_type => $entity_type_info) {
    if ($entity_type_info instanceof \Drupal\Core\Entity\ContentEntityType) {
      $entity_type_label = $entity_type_info->get('label');

      $potential_element = [
        '#type' => 'checkboxes',
        '#title' => $entity_type_label,
        '#options' => array(),
        '#default_value' => $config && isset($config->bundles[$entity_type]) ? $config->bundles[$entity_type] : array(),
      ];

      foreach (\Drupal::entityManager()->getBundleInfo($entity_type) as $bundle => $bundle_info) {
        // Check the access if the bundle can be configured.
        if (empty($bundle_info['admin'])) {
          continue;
        }

        $access_args = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
        if (!isset($access_args['access callback'])) {
          $access_args['access callback'] = 'user_access';
        }
        if (!isset($access_args['access arguments'])) {
          $access_args['access arguments'] = ($access_args['access callback'] = 'user_access') ? array('administer site configuration') : array();
        }

        $access = FALSE;
        if (is_bool($access_args['access callback']) || is_numeric($access_args['access callback'])) {
          $access = (bool) $access_args['access callback'];
        }
        elseif ($access_args['access callback'] == 'user_access') {
          $access = (count($access_args['access arguments']) == 1) ? user_access($access_args['access arguments'][0]) : user_access($access_args['access arguments'][0], $access_args['access arguments'][1]);
        }
        elseif (function_exists($access_args['access callback'])) {
          $access = call_user_func_array($access_args['access callback'], $access_args['access arguments']);
        }
        if ($access) {
          $potential_element['#options'][$bundle] = $bundle_info['label'];
        }
      }

      if (!empty($potential_element['#options'])) {
        $parent_element[$entity_type] = $potential_element;
      }
    }
  }

  // If there were no allowed options then do not make changes to the form.
  $children = Element::children($parent_element);
  if (!empty($children)) {
    $form['visibility']['eba'] = array(
      '#type' => 'fieldset',
      '#title' => t('Entity Block Attachment'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'visibility',
      '#weight' => 30,
    );
    $form['visibility']['eba']['eba_bundles'] = $parent_element;

    $form['visibility']['eba']['eba_respect_visibility'] = array(
      '#type' => 'checkbox',
      '#title' => t('Respect block visibility settings'),
      '#default_value' => $config ? $config->respect_visibility : FALSE,
      '#description' => t('Only display the block on entities if it is not restricted by other visibility settings.'),
    );

    // The block configure form does not explicitly set its submission handler, so
    // add it if necessary before our handler to $form['#submit'], or to the
    // submit button if other modules have added submit callbacks to that.
    if (isset($form['actions']['submit']['#submit'])) {
      $form['actions']['submit']['#submit'][] = 'eba_form_block_admin_configure_submit';
    }
    if (!isset($form['#submit'])) {
      $form['#submit'][] = 'block_admin_configure_submit';
    }
    $form['#submit'][] = 'eba_form_block_admin_configure_submit';
  }
}

/**
 * Additional submission callback for the block configuration form.
 */
function eba_form_block_admin_configure_submit($form, &$form_state) {
  if (isset($form_state['values']['eba_bundles'])) {
    $module = $form_state['values']['module'];
    $delta = $form_state['values']['delta'];
    $all_bundles = $form_state['values']['eba_bundles'];

    foreach ($all_bundles as $entity_type => $bundles) {
      $all_bundles[$entity_type] = array_values(array_filter($bundles));
    }
    $all_bundles = array_filter($all_bundles);

    if (empty($all_bundles)) {
      if ($config = eba_config_load($module, $delta)) {
        eba_config_delete($module, $delta);
      }
    }
    else {
      $config = array(
        'module' => $module,
        'delta' => $delta,
        'bundles' => $all_bundles,
        'respect_visibility' => $form_state['values']['eba_respect_visibility'],
      );
      eba_config_save($config);
    }
  }
}
